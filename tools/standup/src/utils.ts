import { Standup, ActionItem, TeamMember, SpeakerNotes } from './types';

// ─── Time Formatting ────────────────────────────────────────────────

export function formatTime(seconds: number): string {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

export function formatDate(dateStr: string): string {
  const d = new Date(dateStr + 'T00:00:00');
  return d.toLocaleDateString('en-US', {
    weekday: 'short',
    month: 'short',
    day: 'numeric',
    year: 'numeric',
  });
}

// ─── Audio Alert ────────────────────────────────────────────────────

let audioCtx: AudioContext | null = null;

export function playAlert(type: 'soft' | 'warning' | 'end'): void {
  try {
    if (!audioCtx) audioCtx = new AudioContext();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === 'end') {
      // Two gentle tones
      osc.frequency.setValueAtTime(523, now); // C5
      osc.frequency.setValueAtTime(659, now + 0.15); // E5
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
      osc.start(now);
      osc.stop(now + 0.6);
    } else if (type === 'warning') {
      osc.frequency.setValueAtTime(440, now); // A4
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      osc.start(now);
      osc.stop(now + 0.4);
    } else {
      osc.frequency.setValueAtTime(392, now); // G4
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      osc.start(now);
      osc.stop(now + 0.3);
    }
  } catch {
    // Audio not available — silent fail
  }
}

// ─── Summary Generation ─────────────────────────────────────────────

function bulletList(items: string[]): string {
  if (items.length === 0) return '  _None_\n';
  return items.map(item => `  - ${item}`).join('\n') + '\n';
}

function hasContent(notes: SpeakerNotes): boolean {
  return (
    notes.wins.length > 0 ||
    notes.focus.length > 0 ||
    notes.blockers.length > 0 ||
    notes.decisions.length > 0
  );
}

export function generateMarkdownSummary(
  standup: Standup,
  tasks: ActionItem[],
  team: TeamMember[],
): string {
  const date = formatDate(standup.date);
  let md = `# Sola Standup — ${date}\n\n`;

  // Per-speaker updates
  md += `## Team Updates\n\n`;
  for (const speaker of standup.speakers) {
    const member = team.find(m => m.id === speaker.memberId);
    if (!member || !hasContent(speaker)) continue;

    md += `### ${member.name} — ${member.role}\n`;
    if (speaker.wins.length > 0) {
      md += `**Wins**\n${bulletList(speaker.wins)}`;
    }
    if (speaker.focus.length > 0) {
      md += `**Focus**\n${bulletList(speaker.focus)}`;
    }
    if (speaker.blockers.length > 0) {
      md += `**Blockers**\n${bulletList(speaker.blockers)}`;
    }
    if (speaker.decisions.length > 0) {
      md += `**Decisions**\n${bulletList(speaker.decisions)}`;
    }
    if (speaker.links.length > 0) {
      md += `**Links**\n${bulletList(speaker.links)}`;
    }
    md += '\n';
  }

  // Blockers rollup
  const allBlockers = standup.speakers.flatMap(s => {
    const member = team.find(m => m.id === s.memberId);
    return s.blockers.map(b => `${member?.name}: ${b}`);
  });
  if (allBlockers.length > 0) {
    md += `## Blockers\n${bulletList(allBlockers)}\n`;
  }

  // Decisions rollup
  const allDecisions = standup.speakers.flatMap(s => s.decisions);
  if (allDecisions.length > 0) {
    md += `## Decisions\n${bulletList(allDecisions)}\n`;
  }

  // Action items table
  const activeTasks = tasks.filter(t => !t.completed);
  if (activeTasks.length > 0) {
    md += `## Action Items\n\n`;
    md += `| Task | Owner | Priority | Due |\n`;
    md += `|------|-------|----------|-----|\n`;
    for (const task of activeTasks) {
      const owner = team.find(m => m.id === task.ownerId);
      const due = task.dueDate || '—';
      md += `| ${task.title} | ${owner?.name || task.ownerId} | ${task.priority} | ${due} |\n`;
    }
    md += '\n';
  }

  md += `---\n_Generated by Sola Standup_\n`;
  return md;
}

// ─── Email-ready summary (clean plain text) ─────────────────────────

export function generateEmailSummary(
  standup: Standup,
  tasks: ActionItem[],
  team: TeamMember[],
): string {
  const date = new Date(standup.date + 'T00:00:00').toLocaleDateString('en-US', {
    weekday: 'long',
    month: 'long',
    day: 'numeric',
    year: 'numeric',
  });

  let email = `Standup Summary — ${date}\n\n`;

  for (const speaker of standup.speakers) {
    const member = team.find(m => m.id === speaker.memberId);
    if (!member || !hasContent(speaker)) continue;

    email += `${member.name.toUpperCase()} (${member.role})\n`;
    if (speaker.wins.length > 0) {
      email += `  Wins: ${speaker.wins.join('; ')}\n`;
    }
    if (speaker.focus.length > 0) {
      email += `  Focus: ${speaker.focus.join('; ')}\n`;
    }
    if (speaker.blockers.length > 0) {
      email += `  Blockers: ${speaker.blockers.join('; ')}\n`;
    }
    if (speaker.decisions.length > 0) {
      email += `  Decisions: ${speaker.decisions.join('; ')}\n`;
    }
    email += '\n';
  }

  const activeTasks = tasks.filter(t => !t.completed);
  if (activeTasks.length > 0) {
    email += `ACTION ITEMS (${activeTasks.length} open)\n`;
    for (const task of activeTasks) {
      const owner = team.find(m => m.id === task.ownerId);
      let line = `  • ${task.title}`;
      if (owner) line += ` — ${owner.name}`;
      const tags: string[] = [];
      if (task.priority === 'high') tags.push('High');
      if (task.dueDate) tags.push(`due ${task.dueDate}`);
      if (tags.length > 0) line += ` (${tags.join(', ')})`;
      email += line + '\n';
    }
    email += '\n';
  }

  email += '—\nSola Standup';
  return email;
}

// ─── Slack-friendly summary (plain text) ────────────────────────────

export function generateSlackSummary(
  standup: Standup,
  tasks: ActionItem[],
  team: TeamMember[],
): string {
  const date = formatDate(standup.date);
  let text = `*Sola Standup — ${date}*\n\n`;

  for (const speaker of standup.speakers) {
    const member = team.find(m => m.id === speaker.memberId);
    if (!member || !hasContent(speaker)) continue;

    text += `*${member.name}* (${member.role})\n`;
    if (speaker.wins.length > 0) text += `  Wins: ${speaker.wins.join(', ')}\n`;
    if (speaker.focus.length > 0) text += `  Focus: ${speaker.focus.join(', ')}\n`;
    if (speaker.blockers.length > 0) text += `  Blockers: ${speaker.blockers.join(', ')}\n`;
    text += '\n';
  }

  const activeTasks = tasks.filter(t => !t.completed);
  if (activeTasks.length > 0) {
    text += `*Action Items*\n`;
    for (const task of activeTasks) {
      const owner = team.find(m => m.id === task.ownerId);
      text += `  - ${task.title} (${owner?.name}, ${task.priority})\n`;
    }
  }

  return text;
}

// ─── Export Helpers ──────────────────────────────────────────────────

export function downloadJSON(standup: Standup, tasks: ActionItem[]): void {
  const data = JSON.stringify({ standup, tasks }, null, 2);
  downloadFile(data, `standup-${standup.date}.json`, 'application/json');
}

export function downloadCSV(tasks: ActionItem[], team: TeamMember[]): void {
  const header = 'Task,Owner,Priority,Due Date,Status\n';
  const rows = tasks.map(t => {
    const owner = team.find(m => m.id === t.ownerId);
    const status = t.completed ? 'Done' : 'Open';
    return `"${t.title.replace(/"/g, '""')}","${owner?.name || t.ownerId}","${t.priority}","${t.dueDate || ''}","${status}"`;
  });
  downloadFile(header + rows.join('\n'), `tasks-${new Date().toISOString().slice(0, 10)}.csv`, 'text/csv');
}

export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch {
    return false;
  }
}

function downloadFile(content: string, filename: string, type: string): void {
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

// ─── ID Generator ───────────────────────────────────────────────────

export function generateId(): string {
  return Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
}
